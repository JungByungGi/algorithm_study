## 1. 알고리즘 복잡도 계산이 필요한 이유

- 하나의 문제를 푸는 알고리즘은 다양하다.
    - **예시(정수의 절대값 구하기)**
        1. 정수값을 제곱한 값에 다시 루트를 씌우기
        2. 정수가 음수인지 확인해서, 음수일 때만 -1을 곱하기

               → 어느 방식이 더 좋은지를 분석하기 위해, 복잡도를 정의하고 계산함.

## 2. 알고리즘 복잡도 계산 항목

- 시간 복잡도

    알고리즘 실행 속도(반복문이 지배하므로 유의)

- 공간 복잡도

    알고리즘이 사용하는 메모리 사이즈

## 3. 알고리즘 성능 표기법

- Big O (빅오) 표기법 : O(n)
    - 알고리즘 최악의 실행 시간을 표기
    - **아무리 최악의 상황이라도, 이 정도의 성능은 보장한다는 의미**
    - 빅오 표기법을 중심으로 시간복잡도를 입히는 게 좋다.(제일 많이 쓰임.)
- Ω(오메가) 표기법 : Ω(n)
    - 알고리즘 최상의 실행 시간을 표기
- Θ(세타) 표기법 : Θ(n)
    - 알고리즘 평균 실행 시간을 표기

## 4. 빅오 표기법

- O(입력)
    - 입력 n에 따라 결정되는 ㄴ시간 복잡도 함수
    - ex) O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(2^n) < O(n!)

        logn ⇒ log2n(밑이 2인 로그)를 의미 (n = 2^x)

    - 입력 n의 크기에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있다.
    - 입력 n에 따랏, 몇 번 실행되는지 계산
        - 표현식에 가장 큰 영향을 미치는 n의 단위로 계산(n은 무한대로 본다.)
        - **예제 1. n이 1이든, 100이든, 1000이든 무조건 상수회 실행한다. : O(1)**

            ```tsx
            if n > 10:
            	print(n)
            ```

        - **예제 2. n에 따라 n번, n+10번, 3n+10번 등 실행한다 : O(n)**

            ```tsx
            for index in range(n):
            		print(index)
            ```

        - **예제 3. n에 따라 n^2번, n^2+1000번, 100n^2-100번 등 실행한다 : O(n^2)**

            ```tsx
            for index in range(n):
            	for num in range(n):
            		print(num)
            ```

## 5. 알고리즘 예제1 : 1부터 n까지의 합을 구하는 알고리즘1

- 방법 1
    - 시간 복잡도 O(n)

```tsx
 def sum_all(n):
		total = 0
		for num in range(1, n+1):
				total += num
		return totalq
```

- 방법 2
    - 시간 복잡도 O(1)

        반복문이 따로 없기 때문이다.

```tsx
def sum_all(n):
		return int(n*(n+1)/2)
```

∴ 방법 2가 더 효율적인 알고리즘이다.